const dotenv = require("dotenv").config(), userModel = require("../models/userModel"), bcrypt = require("bcrypt"), jwt = require("jsonwebtoken"), moment = require("moment"), Excel = require("exceljs"), path = require("path"); let date = new Date; class clientControllers { static login = async (d, b) => { let { email: c, password: e } = d.body; if (console.log(d.body), c && e) try { let a = await userModel.findOne({ email: c }); if (null != a) { let f = await bcrypt.compare(e, a.password); if (console.log(f), c === a.email && f) { let h = jwt.sign({ userID: a._id }, process.env.JWT_SECRET_KEY, { expiresIn: "1d" }), i = { data: { token: h }, status: "SUCCESS", message: "Login Success", type: "CLIENT", name: a.username, account: a.accountNumber }; b.send(i) } else b.send({ status: "FAILED", message: "email and password are invalid" }) } else b.send({ message: "Invalid login credentials", status: "FAILED" }) } catch (g) { console.log(g), b.send({ status: "FAILED", message: "unable to login user", err: g.message }) } else b.send({ status: "FAILED", message: "Error all fields are required" }) }; static changePassword = async (b, a) => { let { current_password: d, confirm_password: e, new_password: c } = b.body; try { if (console.log(b.body), d && e && c) { if (c !== e) a.send({ status: "FAILED", message: "password dosen't Match" }); else { let f = await userModel.findOne({ _id: b.id }), g = await bcrypt.compare(d, f.password), h = await bcrypt.genSalt(10), i = await bcrypt.hash(c, h); if (g) { let j = await userModel.findByIdAndUpdate(b.id, { $set: { password: i } }); console.log(j), a.send({ status: "SUCCESS", message: "Successfully change password", newPassword: c }) } else a.send({ status: "FAILED", message: "Password is incorrect" }) } } else a.send({ status: "FAILED", message: "All fields are required" }) } catch (k) { a.send({ message: "Something went wrong", status: "FAILED" }) } }; static checkBalance = async (b, a) => { try { let c = await userModel.findOne({ "_id": b.id }, { balance: 1, _id: 0 }); a.send({ status: "SUCCESS", code: 200, balance: `Rs. ${c.balance.toFixed(2)}/-` }) } catch (d) { a.send("Errror cannot check balance something went wrong") } }; static depositAmount = async (d, c) => { let { depositeAmount: a, password: f } = d.body; console.log(a); try { let b = await userModel.findOne({ "_id": d.id }); if (b) { if (!0 != b.isFreez) { if (a >= 1) { let g = await bcrypt.compare(f, b.password); if (g) { await userModel.updateOne({ "_id": d.id }, { $set: { balance: b.balance + Number(a) } }); let e = b.lastTransaction, h = { type: "DEPOSITE", date: moment(new Date).format("MMMM Do YYYY, h:mm:ss a"), debit: 0, credit: a, balance: b.balance + a, to: "self" }; e.unshift(h), await userModel.updateOne({ "_id": d.id }, { $set: { lastTransaction: e } }), c.send({ message: `Rs. ${a}/- Deposite Successfully`, status: "SUCCESS" }) } else c.send({ message: "Incorrect Password", status: "FAILED" }) } else c.send({ message: "Error enter valid Amount", status: "FAILED" }) } else c.send({ message: "Error Sorry your account is Freez kindly contact Admin", status: "FAILED" }) } else c.send({ message: "Error Something went wrong", status: "FAILED" }) } catch (i) { } }; static withdrawAmount = async (d, a) => { let { withdrawAmount: c, password: g } = d.body; console.log(d.body); try { let b = await userModel.findOne({ "_id": d.id }); if (b) { if (!0 != b.isFreez) { let e = await bcrypt.compare(g, b.password); if (console.log(e), e) { if (c <= b.balance) { if (c >= .1) { await userModel.updateOne({ "_id": d.id }, { $set: { balance: (b.balance - Number(c)).toFixed(2) } }); let f = b.lastTransaction, h = { type: "WITHDRAW", date: moment(new Date).format("MMMM Do YYYY, h:mm:ss a"), debit: c, credit: 0, balance: b.balance - c, to: "self" }; f.unshift(h), await userModel.updateOne({ "_id": d.id }, { $set: { lastTransaction: f } }), a.send({ message: `Rs. ${c}/- amount withdraw successfully`, status: "SUCCESS" }) } else a.send({ message: "Enter valid ammount", status: "FAILED" }) } else a.send({ message: "Insufficient funds", status: "FAILED" }) } else a.send({ message: "Password is Incorrect", status: "FAILED" }) } else a.send({ message: "Error Sorry your account is Freez kindly contact Admin", status: "FAILED" }) } else a.send({ message: "Error Something went wrong", status: "FAILED" }) } catch (i) { a.send({ message: "Error cannot not Deposite Amount", status: "FAILED" }) } }; static transferAmount = async (e, b) => { let { amount: a, account: d, password: g } = e.body; console.log(e.body); try { let c = await userModel.findOne({ "_id": e.id }), f = await userModel.findOne({ accountNumber: d }); if (c) { let j = await bcrypt.compare(g, c.password); if (g && j) { if (!0 != c.isFreez) { if (c.balance >= a) { if (f) { await userModel.updateOne({ accountNumber: d }, { $set: { balance: f.balance + Number(a) } }), await userModel.updateOne({ "_id": e.id }, { $set: { balance: c.balance - Number(a) } }); let h = c.lastTransaction, k = { type: "TRANSFER", date: moment(new Date).format("MMMM Do YYYY, h:mm:ss a"), debit: a, credit: 0, balance: c.balance - Number(a), to: d }; h.unshift(k), await userModel.updateOne({ "_id": e.id }, { $set: { lastTransaction: h } }); let i = f.lastTransaction, l = { type: "WITHDRAW", date: moment(new Date).format("MMMM Do YYYY, h:mm:ss a"), debit: 0, credit: a, balance: f.balance + Number(a), to: d }; i.unshift(l), await userModel.updateOne({ accountNumber: d }, { $set: { lastTransaction: i } }), b.send({ message: `Successfully ${a}/RS Transfer To ${d} Number`, status: "SUCCESS" }) } else b.send({ message: "Receiver account not found", status: "FAILED" }) } else b.send({ message: "Insufficient funds", status: "FAILED" }) } else b.send({ message: "Error Sorry your account is Freez kindly contact Admin", status: "FAILED" }) } else b.send({ status: "FAILED", message: "Incorrect password" }) } else b.send({ message: "Something went wrong", status: "FAILED" }) } catch (m) { b.send({ message: "Error cannot transfer amount", status: "FAILED" }) } }; static accountNumber = async (c, a) => { try { let b = await userModel.findOne({ "_id": c.id }); b ? a.send({ account: b.accountNumber }) : a.send({ message: "Something went wrong", status: "FAILED" }) } catch (d) { a.send({ message: "Error cannot fetch Account Number", status: "FAILED" }) } }; static getExcel = async (g, e) => { try { let f = await userModel.findOne({ "_id": g.id }); if (f) try { let d = f.lastTransaction, h = new Excel.Workbook, a = h.addWorksheet("Sheet1"); a.getRow(1).getCell(1).value = "Sr.No", a.getRow(1).getCell(2).value = "Date", a.getRow(1).getCell(3).value = "Type", a.getRow(1).getCell(4).value = "Debit", a.getRow(1).getCell(5).value = "Credit", a.getRow(1).getCell(6).value = "Balance", a.getRow(1).getCell(7).value = "To"; let b = 0, j = a.getColumn(2), k = a.getColumn(3), l = a.getColumn(4), m = a.getColumn(5), n = a.getColumn(6), o = a.getColumn(7); j.width = 30, k.width = 20, m.width = 15, n.width = 15, o.width = 15, l.width = 15; for (let c = 0; c < d.length; c++)b += 1, a.getRow(b + 1).getCell(1).value = b, a.getRow(b + 1).getCell(2).value = d[c].date, a.getRow(b + 1).getCell(3).value = d[c].type, a.getRow(b + 1).getCell(4).value = Number(d[c].debit), a.getRow(b + 1).getCell(5).value = Number(d[c].credit), a.getRow(b + 1).getCell(6).value = Number(d[c].balance), a.getRow(b + 1).getCell(7).value = d[c].to; let i = `${f.username.split(" ").join("-")}_${moment(date).format("DD-MM-YY")}_${f.accountNumber}.xls`, p = path.join(process.cwd(), "Excel", "Client", i); try { await h.xlsx.writeFile(p), await userModel.updateOne({ "_id": g.id }, { $set: { filePath: `/Excel/Client/${i}` } }), e.send({ message: "Successfully Created Link", status: "SUCCESS", link: `client/download/${f.accountNumber}` }) } catch (r) { e.send({ message: "Error in saving XLSX", status: "FAILED" }) } } catch (q) { console.log(q), e.send({ message: "Error in writing Excel", status: "FAILED" }) } else e.send({ message: "Error User not found", status: "FAILED" }) } catch (s) { e.send({ message: "Error cannot Create excel", status: "FAILED" }) } }; static getTransaction = async (e, d) => { try { let a = await userModel.findOne({ "_id": e.id }).select("lastTransaction -_id"), b = []; if (a.length > 10) for (let c = 0; c < 10; c++)b.push(a.lastTransaction[c]); else b = a.lastTransaction; d.send({ status: "SUCCESS", data: b }) } catch (f) { d.send({ message: "Error initia server error", status: "FAILED" }) } }; static applyCheckBook = async (b, a) => { let { name: c, address: d, password: e } = b.body; try { let f = await userModel.findOne({ "_id": b.id }); c && d && e ? f ? await bcrypt.compare(e, f.password) ? (await userModel.updateOne({ _id: b.id }, { $set: { isCheckBookApply: !0, checkBookDetails: { name: c, address: d, dateOfApply: new Date } } }), a.status(200).send({ message: "Successfully apply for CheckBook", status: "SUCCESS" })) : a.status(422).send({ message: "Password is Incorrect", status: "FAILED" }) : a.status(500).send({ message: "User Not found", status: "FAILED" }) : a.status(422).send({ message: "All fields are required", status: "FAILED" }) } catch (g) { a.status(500).send({ message: "Initial server error", status: "FAILED" }) } }; static download = async (b, a) => { try { let c = `${process.cwd()}/${(await userModel.findOne({ accountNumber: b.params.account })).filePath}`; a.download(c) } catch (d) { a.status(500).send({ message: "Initial server error", status: "FAILED" }) } } } module.exports = clientControllers